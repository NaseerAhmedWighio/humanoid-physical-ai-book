---
sidebar_position: 7
title: "Week 4-5: Gazebo Fundamentals"
---

# Week 4-5: Gazebo Fundamentals

## Introduction to Gazebo Simulation

Welcome to Weeks 4-5 of our comprehensive course on Physical AI and Humanoid Robotics. In these weeks, we'll dive deep into Gazebo, one of the most important simulation environments in robotics. Gazebo provides realistic physics simulation, sensor modeling, and visualization capabilities that are essential for developing, testing, and validating humanoid robotic systems.

Simulation is a critical component of humanoid robotics development for several key reasons:
- **Safety**: Testing complex locomotion and manipulation behaviors without risk of damaging expensive hardware
- **Cost-Effectiveness**: Iterating on control algorithms and system designs without physical robot time
- **Reproducibility**: Creating consistent test conditions for algorithm validation
- **Speed**: Running simulations faster than real-time to accelerate development and training
- **Edge Case Testing**: Creating dangerous or rare scenarios safely in simulation

Gazebo has become the de facto standard for robotics simulation due to its:
- Accurate physics engine based on ODE, Bullet, or DART
- Realistic sensor simulation capabilities
- Extensive model database and plugin architecture
- Seamless integration with ROS/ROS 2
- Active development and strong community support

## Gazebo Architecture and Components

### Core Architecture

Gazebo's architecture consists of several key components that work together to provide a complete simulation environment:

**Gazebo Server (gzserver)**: The core simulation engine that handles physics calculations, sensor updates, and plugin execution. It runs in the background and can be controlled through various interfaces.

**Gazebo Client (gzclient)**: The graphical user interface that allows users to visualize the simulation, interact with objects, and monitor simulation state. Multiple clients can connect to the same server.

**Model Database**: A repository of pre-built robot and environment models that can be easily incorporated into simulations.

**Plugin System**: A flexible architecture that allows custom functionality to be added to the simulation, including custom sensors, controllers, and communication interfaces.

### Physics Engine Integration

Gazebo supports multiple physics engines, each with different strengths:

- **ODE (Open Dynamics Engine)**: Default choice, good balance of accuracy and performance
- **Bullet**: Excellent for complex contact scenarios and articulated bodies
- **DART (Dynamic Animation and Robotics Toolkit)**: Advanced for complex humanoid kinematics

The physics engine handles:
- Rigid body dynamics and collisions
- Joint constraints and limits
- Contact modeling and friction
- Mass properties and inertial calculations

## Setting Up Gazebo with ROS 2

### Installation and Configuration

To use Gazebo with ROS 2, you'll need to install the appropriate packages:

```bash
# Install Gazebo Harmonic (or appropriate version for your ROS 2 distribution)
sudo apt install ros-humble-gazebo-*

# Install ROS 2 Gazebo packages
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins
```

### Gazebo-ROS Integration

The `gazebo_ros_pkgs` package provides bridges between Gazebo's native API and ROS 2 topics, services, and actions. This integration allows you to:

- Control simulated robots using ROS 2 nodes
- Access simulated sensor data through ROS 2 topics
- Use the same code for both simulation and real robots
- Leverage ROS 2 tools for visualization and debugging

## Creating Robot Models for Gazebo

### URDF (Unified Robot Description Format)

URDF is the standard format for describing robot models in ROS. A complete URDF for Gazebo simulation includes:

```xml
<?xml version="1.0"?>
<robot name="humanoid_robot" xmlns:xacro="http://ros.org/wiki/xacro">

  <!-- Base Link -->
  <link name="base_link">
    <inertial>
      <mass value="10.0"/>
      <origin xyz="0 0 0.5"/>
      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0.5"/>
      <geometry>
        <box size="0.3 0.2 1.0"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0.5"/>
      <geometry>
        <box size="0.3 0.2 1.0"/>
      </geometry>
    </collision>
  </link>

  <!-- Head -->
  <link name="head">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 0"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0"/>
      <geometry>
        <sphere radius="0.15"/>
      </geometry>
      <material name="white">
        <color rgba="1 1 1 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0"/>
      <geometry>
        <sphere radius="0.15"/>
      </geometry>
    </collision>
  </link>

  <joint name="neck_joint" type="fixed">
    <parent link="base_link"/>
    <child link="head"/>
    <origin xyz="0 0 1.0"/>
  </joint>

  <!-- Left Upper Arm -->
  <link name="left_upper_arm">
    <inertial>
      <mass value="1.5"/>
      <origin xyz="0 0 -0.15"/>
      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.15"/>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
      <material name="red">
        <color rgba="1 0 0 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.15"/>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
    </collision>
  </link>

  <joint name="left_shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_upper_arm"/>
    <origin xyz="0.15 0 0.7"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
    <dynamics damping="0.1" friction="0.0"/>
  </joint>

  <!-- Right Upper Arm -->
  <link name="right_upper_arm">
    <inertial>
      <mass value="1.5"/>
      <origin xyz="0 0 -0.15"/>
      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.15"/>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
      <material name="red">
        <color rgba="1 0 0 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.15"/>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
    </collision>
  </link>

  <joint name="right_shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="right_upper_arm"/>
    <origin xyz="-0.15 0 0.7"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>
    <dynamics damping="0.1" friction="0.0"/>
  </joint>

  <!-- Left Upper Leg -->
  <link name="left_upper_leg">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 -0.25"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.02"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.25"/>
      <geometry>
        <cylinder length="0.5" radius="0.06"/>
      </geometry>
      <material name="green">
        <color rgba="0 1 0 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.25"/>
      <geometry>
        <cylinder length="0.5" radius="0.06"/>
      </geometry>
    </collision>
  </link>

  <joint name="left_hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_upper_leg"/>
    <origin xyz="0.08 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.785" upper="0.785" effort="200" velocity="1"/>
    <dynamics damping="0.2" friction="0.0"/>
  </joint>

  <!-- Right Upper Leg -->
  <link name="right_upper_leg">
    <inertial>
      <mass value="2.0"/>
      <origin xyz="0 0 -0.25"/>
      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.02"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.25"/>
      <geometry>
        <cylinder length="0.5" radius="0.06"/>
      </geometry>
      <material name="green">
        <color rgba="0 1 0 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.25"/>
      <geometry>
        <cylinder length="0.5" radius="0.06"/>
      </geometry>
    </collision>
  </link>

  <joint name="right_hip_joint" type="revolute">
    <parent link="base_link"/>
    <child link="right_upper_leg"/>
    <origin xyz="-0.08 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.785" upper="0.785" effort="200" velocity="1"/>
    <dynamics damping="0.2" friction="0.0"/>
  </joint>

  <!-- Gazebo-specific elements -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
    <mu1>0.2</mu1>
    <mu2>0.2</mu2>
  </gazebo>

  <gazebo reference="head">
    <material>Gazebo/White</material>
  </gazebo>

  <gazebo reference="left_upper_arm">
    <material>Gazebo/Red</material>
  </gazebo>

  <gazebo reference="right_upper_arm">
    <material>Gazebo/Red</material>
  </gazebo>

  <gazebo reference="left_upper_leg">
    <material>Gazebo/Green</material>
  </gazebo>

  <gazebo reference="right_upper_leg">
    <material>Gazebo/Green</material>
  </gazebo>

  <!-- Transmission elements for ROS control -->
  <transmission name="left_shoulder_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_shoulder_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="left_shoulder_motor">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <transmission name="right_shoulder_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="right_shoulder_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="right_shoulder_motor">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <transmission name="left_hip_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_hip_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="left_hip_motor">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <transmission name="right_hip_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="right_hip_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
    <actuator name="right_hip_motor">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

</robot>
```

### SDF (Simulation Description Format)

SDF is Gazebo's native format that extends URDF with simulation-specific properties. Here's a basic SDF world file:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Include standard models -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Add a simple box obstacle -->
    <model name="obstacle_box">
      <pose>2 0 0.5 0 0 0</pose>
      <link name="link">
        <inertial>
          <mass>1.0</mass>
          <inertia>
            <ixx>0.083</ixx>
            <ixy>0.0</ixy>
            <ixz>0.0</ixz>
            <iyy>0.083</iyy>
            <iyz>0.0</iyz>
            <izz>0.083</izz>
          </inertia>
        </inertial>
        <visual name="visual">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.5 0.5 0.5 1</ambient>
            <diffuse>0.7 0.7 0.7 1</diffuse>
            <specular>0.1 0.1 0.1 1</specular>
          </material>
        </visual>
        <collision name="collision">
          <geometry>
            <box>
              <size>1 1 1</size>
            </box>
          </geometry>
        </collision>
      </link>
    </model>

    <!-- Add a ramp for testing locomotion -->
    <model name="ramp">
      <pose>3 0 0 0 0.3 0</pose>
      <link name="ramp_link">
        <inertial>
          <mass>10.0</mass>
          <inertia>
            <ixx>10.0</ixx>
            <ixy>0.0</ixy>
            <ixz>0.0</ixz>
            <iyy>10.0</iyy>
            <iyz>0.0</iyz>
            <izz>10.0</izz>
          </inertia>
        </inertial>
        <visual name="ramp_visual">
          <geometry>
            <mesh>
              <uri>file://meshes/ramp.dae</uri>
            </mesh>
          </geometry>
        </visual>
        <collision name="ramp_collision">
          <geometry>
            <mesh>
              <uri>file://meshes/ramp.dae</uri>
            </mesh>
          </geometry>
        </collision>
      </link>
    </model>

    <!-- Include our humanoid robot -->
    <include>
      <uri>model://humanoid_robot</uri>
      <pose>0 0 1.2 0 0 0</pose>
    </include>

    <!-- Add sensors to the world -->
    <actor name="walking_person">
      <pose>5 0 1.0 0 0 0</pose>
      <skin>
        <filename>walking.dae</filename>
        <scale>1.0</scale>
      </skin>
      <animation name="walking" filename="walking.dae" loop="true"/>
      <script>
        <trajectory id="0" type="circle">
          <waypoint>
            <time>0</time>
            <pose>5 0 1.0 0 0 0</pose>
          </waypoint>
          <waypoint>
            <time>10</time>
            <pose>5 5 1.0 0 0 0</pose>
          </waypoint>
          <waypoint>
            <time>20</time>
            <pose>0 5 1.0 0 0 0</pose>
          </waypoint>
          <waypoint>
            <time>30</time>
            <pose>0 0 1.0 0 0 0</pose>
          </waypoint>
        </trajectory>
      </script>
    </actor>

  </world>
</sdf>
```

## Advanced Gazebo Features

### Sensor Simulation

Gazebo provides realistic simulation of various sensors commonly used in humanoid robots:

#### Camera Sensors
```xml
<gazebo reference="head">
  <sensor name="camera" type="camera">
    <update_rate>30</update_rate>
    <camera name="head_camera">
      <horizontal_fov>1.047</horizontal_fov> <!-- 60 degrees -->
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>10.0</far>
      </clip>
    </camera>
    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
      <frame_name>head_camera_optical_frame</frame_name>
      <topic_name>camera/image_raw</topic_name>
      <hack_baseline>0.07</hack_baseline>
    </plugin>
  </sensor>
</gazebo>
```

#### IMU Sensors
```xml
<gazebo reference="base_link">
  <sensor name="imu" type="imu">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.001</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.001</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.001</stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0.0</mean>
            <stddev>0.017</stddev>
          </noise>
        </z>
      </linear_acceleration>
    </imu>
    <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">
      <topicName>imu/data</topicName>
      <bodyName>base_link</bodyName>
      <frameName>base_link</frameName>
      <serviceName>imu/service</serviceName>
      <gaussianNoise>0.001</gaussianNoise>
      <updateRate>100.0</updateRate>
    </plugin>
  </sensor>
</gazebo>
```

#### Force/Torque Sensors
```xml
<gazebo reference="left_foot">
  <sensor name="left_foot_force_torque" type="force_torque">
    <update_rate>100</update_rate>
    <always_on>true</always_on>
    <plugin name="left_foot_ft_plugin" filename="libgazebo_ros_ft_sensor.so">
      <topicName>left_foot/force_torque</topicName>
      <frameName>left_foot</frameName>
    </plugin>
  </sensor>
</gazebo>
```

### Physics Parameters and Tuning

Proper physics configuration is crucial for realistic humanoid simulation:

#### Global Physics Settings
```xml
<sdf version="1.7">
  <world name="humanoid_world">
    <physics type="ode">
      <max_step_size>0.001</max_step_size>  <!-- Time step for physics -->
      <real_time_factor>1.0</real_time_factor>  <!-- Real-time simulation -->
      <real_time_update_rate>1000</real_time_update_rate>  <!-- Physics updates per second -->
      <gravity>0 0 -9.8</gravity>

      <!-- ODE-specific parameters -->
      <ode>
        <solver>
          <type>quick</type>  <!-- or 'pgs', 'dantzig' -->
          <iters>100</iters>  <!-- Solver iterations -->
          <sor>1.3</sor>  <!-- Successive over-relaxation -->
        </solver>
        <constraints>
          <cfm>0.0</cfm>  <!-- Constraint force mixing -->
          <erp>0.2</erp>  <!-- Error reduction parameter -->
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>
  </world>
</sdf>
```

#### Material Properties
```xml
<gazebo reference="left_foot">
  <mu1>0.8</mu1>  <!-- Friction coefficient 1 -->
  <mu2>0.8</mu2>  <!-- Friction coefficient 2 -->
  <kp>1000000.0</kp>  <!-- Contact stiffness -->
  <kd>100.0</kd>    <!-- Contact damping -->
  <max_vel>100.0</max_vel>  <!-- Maximum contact penetration velocity -->
  <min_depth>0.001</min_depth>  <!-- Minimum contact depth -->
</gazebo>
```

## Gazebo Plugins and Custom Functionality

### Writing Custom Plugins

Gazebo plugins extend simulation functionality. Here's an example of a custom controller plugin:

```cpp
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <stdio.h>

namespace gazebo
{
  class HumanoidBalancePlugin : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)
    {
      // Store the model pointer for convenience
      this->model = _parent;

      // Get pointers to the joints
      this->leftHipJoint = this->model->GetJoint("left_hip_joint");
      this->rightHipJoint = this->model->GetJoint("right_hip_joint");

      // Listen to the update event. This event is broadcast every
      // simulation iteration.
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&HumanoidBalancePlugin::OnUpdate, this));

      gzdbg << "HumanoidBalancePlugin loaded!\n";
    }

    // Called by the world update start event
    public: void OnUpdate()
    {
      // Apply simple balance control
      double currentAngle = this->model->GetWorldPose().rot.GetRoll();
      double targetAngle = 0.0;
      double error = targetAngle - currentAngle;

      // Simple PD controller
      double kp = 10.0;
      double kd = 1.0;
      double angularVelocity = this->model->GetWorldLinearVel().z;

      double torque = kp * error - kd * angularVelocity;

      // Apply torque to hip joints
      this->leftHipJoint->SetForce(0, torque);
      this->rightHipJoint->SetForce(0, torque);
    }

    // Pointer to the model
    private: physics::ModelPtr model;

    // Pointers to the joints
    private: physics::JointPtr leftHipJoint;
    private: physics::JointPtr rightHipJoint;

    // Event connection
    private: event::ConnectionPtr updateConnection;
  };

  // Register this plugin with the simulator
  GZ_REGISTER_MODEL_PLUGIN(HumanoidBalancePlugin)
}
```

### ROS Integration Plugins

For ROS 2 integration, Gazebo provides several built-in plugins:

```xml
<!-- Joint state publisher -->
<gazebo>
  <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
    <ros>
      <namespace>/humanoid_robot</namespace>
      <remapping>~/out:=joint_states</remapping>
    </ros>
    <update_rate>30</update_rate>
    <joint_name>left_shoulder_joint</joint_name>
    <joint_name>right_shoulder_joint</joint_name>
    <joint_name>left_hip_joint</joint_name>
    <joint_name>right_hip_joint</joint_name>
  </plugin>
</gazebo>

<!-- Joint trajectory controller -->
<gazebo>
  <plugin name="ros_control" filename="libgazebo_ros_control.so">
    <robotNamespace>/humanoid_robot</robotNamespace>
    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
  </plugin>
</gazebo>
```

## ROS 2 Control Integration

### Setting up ros2_control

ROS 2 Control provides a hardware abstraction layer that works seamlessly with Gazebo:

```yaml
# controller_manager.yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    left_leg_controller:
      type: position_controllers/JointGroupPositionController

    right_leg_controller:
      type: position_controllers/JointGroupPositionController

left_leg_controller:
  ros__parameters:
    joints:
      - left_hip_joint
      - left_knee_joint
      - left_ankle_joint

right_leg_controller:
  ros__parameters:
    joints:
      - right_hip_joint
      - right_knee_joint
      - right_ankle_joint
```

### Controller Launch File

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.conditions import IfCondition
from launch.event_handlers import OnProcessExit
from launch.substitutions import Command, LaunchConfiguration
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
import os

def generate_launch_description():
    # Declare arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    gui = LaunchConfiguration('gui', default='true')

    # Get URDF via xacro
    robot_description_content = Command([
        'xacro ',
        os.path.join(
            FindPackageShare('humanoid_description').find('humanoid_description'),
            'urdf',
            'humanoid.urdf.xacro'
        )
    ])
    robot_description = {'robot_description': robot_description_content}

    # Spawn entity node
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', 'robot_description',
            '-entity', 'humanoid_robot',
            '-x', '0',
            '-y', '0',
            '-z', '1.0'
        ],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        output='both',
        parameters=[robot_description, {'use_sim_time': use_sim_time}]
    )

    # Controllers
    joint_state_broadcaster_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['joint_state_broadcaster'],
        parameters=[{'use_sim_time': use_sim_time}],
    )

    left_leg_controller_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['left_leg_controller'],
        parameters=[{'use_sim_time': use_sim_time}],
    )

    right_leg_controller_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['right_leg_controller'],
        parameters=[{'use_sim_time': use_sim_time}],
    )

    # Delay rviz start after `joint_state_broadcaster`
    delay_rviz_after_joint_state_broadcaster_spawner = RegisterEventHandler(
        event_handler=OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[rviz_node],
        )
    )

    # Delay start of joint state broadcaster after xcaro has been started
    delay_joint_state_broadcaster_after_robot_state_publisher_spawner = RegisterEventHandler(
        event_handler=OnProcessExit(
            target_action=robot_state_publisher,
            on_exit=[joint_state_broadcaster_spawner],
        )
    )

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            get_package_share_directory('gazebo_ros'),
            '/launch',
            '/gazebo.launch.py'
        ]),
    )

    return LaunchDescription([
        # Launch Arguments
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='true',
            description='Use simulation (Gazebo) clock if true'
        ),
        DeclareLaunchArgument(
            'gui',
            default_value='true',
            description='Set to "false" to run headless'
        ),

        # Nodes
        gazebo,
        robot_state_publisher,
        spawn_entity,
        joint_state_broadcaster_spawner,
        left_leg_controller_spawner,
        right_leg_controller_spawner,
    ])
```

## Advanced Simulation Techniques

### Domain Randomization

Domain randomization improves the transfer of learned behaviors from simulation to reality:

```python
import random
import numpy as np

class DomainRandomization:
    def __init__(self):
        self.param_ranges = {
            'mass_multiplier': (0.8, 1.2),
            'friction_range': (0.1, 1.0),
            'gravity_range': (-10.0, -9.0),
            'sensor_noise_range': (0.001, 0.01),
            'actuator_delay_range': (0.0, 0.01)
        }

    def randomize_robot_params(self, robot_model):
        """Randomize robot parameters for domain randomization"""
        # Randomize link masses
        for link in robot_model.links:
            mass_multiplier = random.uniform(*self.param_ranges['mass_multiplier'])
            link.mass *= mass_multiplier

        # Randomize joint friction
        for joint in robot_model.joints:
            friction = random.uniform(*self.param_ranges['friction_range'])
            joint.friction = friction

    def randomize_environment(self, world_model):
        """Randomize environment parameters"""
        # Randomize gravity
        gravity_z = random.uniform(*self.param_ranges['gravity_range'])
        world_model.gravity = [0, 0, gravity_z]

        # Randomize floor friction
        floor_friction = random.uniform(*self.param_ranges['friction_range'])
        world_model.floor_friction = floor_friction

    def randomize_sensors(self, sensor_models):
        """Randomize sensor parameters"""
        for sensor in sensor_models:
            noise_level = random.uniform(*self.param_ranges['sensor_noise_range'])
            sensor.noise_level = noise_level

    def randomize_actuators(self, actuator_models):
        """Randomize actuator parameters"""
        for actuator in actuator_models:
            delay = random.uniform(*self.param_ranges['actuator_delay_range'])
            actuator.delay = delay
```

### Multi-Robot Simulation

Simulating multiple robots simultaneously:

```xml
<!-- Multi-robot world file -->
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="multi_humanoid_world">
    <!-- Common elements -->
    <include>
      <uri>model://ground_plane</uri>
    </include>
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- First humanoid robot -->
    <include>
      <uri>model://humanoid_robot</uri>
      <name>humanoid_1</name>
      <pose>-1 0 1.0 0 0 0</pose>
    </include>

    <!-- Second humanoid robot -->
    <include>
      <uri>model://humanoid_robot</uri>
      <name>humanoid_2</name>
      <pose>1 0 1.0 0 0 0</pose>
    </include>

    <!-- Third humanoid robot -->
    <include>
      <uri>model://humanoid_robot</uri>
      <name>humanoid_3</name>
      <pose>0 1 1.0 0 0 1.57</pose>
    </include>

    <!-- Environment obstacles -->
    <model name="obstacle_1">
      <pose>0 2 0.5 0 0 0</pose>
      <include>
        <uri>model://cube_1m</uri>
      </include>
    </model>

    <model name="obstacle_2">
      <pose>2 0 0.5 0 0 0</pose>
      <include>
        <uri>model://cube_1m</uri>
      </include>
    </model>

  </world>
</sdf>
```

### Performance Optimization

Optimizing Gazebo for large-scale simulations:

#### Physics Optimization
```xml
<physics type="ode">
  <max_step_size>0.002</max_step_size>  <!-- Larger step for performance -->
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>500</real_time_update_rate>  <!-- Reduced updates -->
  <gravity>0 0 -9.8</gravity>

  <ode>
    <solver>
      <type>quick</type>  <!-- Fast solver -->
      <iters>20</iters>   <!-- Reduced iterations -->
      <sor>1.0</sor>
    </solver>
    <constraints>
      <cfm>0.0001</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>10.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

#### Visual Optimization
```xml
<scene>
  <ambient>0.4 0.4 0.4 1</ambient>
  <background>0.8 0.8 0.8 1</background>
  <shadows>false</shadows>  <!-- Disable shadows for performance -->
</scene>
```

## Debugging and Troubleshooting

### Common Gazebo Issues

#### Robot Falling Through Ground
- Check collision geometries in URDF
- Verify mass and inertia parameters
- Adjust physics parameters (CFM, ERP)
- Ensure proper joint limits and dynamics

#### Unstable Simulation
- Reduce time step (`max_step_size`)
- Increase solver iterations
- Adjust constraint parameters
- Check for conflicting joint constraints

#### Joint Limits Not Working
- Verify joint limit values in URDF
- Check transmission configurations
- Ensure proper joint types (revolute vs continuous)
- Verify controller configurations

### Debugging Tools

#### Gazebo Topics and Services
```bash
# List all Gazebo topics
ros2 topic list | grep gazebo

# Monitor physics updates
ros2 topic echo /clock

# Check model states
ros2 topic echo /model_states

# Monitor joint states
ros2 topic echo /joint_states
```

#### Visualization
```bash
# Launch Gazebo client separately
gzclient

# Use RViz for ROS visualization
ros2 run rviz2 rviz2

# Monitor TF transforms
ros2 run tf2_tools view_frames
```

## Best Practices for Humanoid Simulation

### Model Quality
- Use realistic mass and inertia properties
- Include proper collision geometries
- Add visual elements for debugging
- Implement proper joint limits and dynamics

### Physics Configuration
- Balance accuracy with performance
- Tune parameters for your specific robot
- Test with various scenarios
- Validate against real robot behavior

### Control Integration
- Use ros2_control for hardware abstraction
- Implement proper safety limits
- Include sensor noise models
- Test controllers in simulation before hardware

### Validation Process
- Compare simulation and real robot behavior
- Validate sensor models against real sensors
- Test controllers in both environments
- Document differences and limitations

## Practical Exercise: Complete Humanoid Simulation

Let's create a complete simulation example that brings together all concepts:

### 1. Create a launch file for the complete simulation:

```python
# launch/humanoid_simulation.launch.py
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution, TextSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
import os

def generate_launch_description():
    # Arguments
    use_sim_time = DeclareLaunchArgument(
        'use_sim_time',
        default_value='true',
        description='Use simulation clock if true'
    )

    world_file = DeclareLaunchArgument(
        'world',
        default_value='humanoid_world.sdf',
        description='Choose one of the world files from `/humanoid_gazebo/worlds`'
    )

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
        launch_arguments={
            'world': PathJoinSubstitution([
                FindPackageShare('humanoid_gazebo'),
                'worlds',
                'humanoid_world.sdf'
            ]),
            'verbose': 'false',
        }.items()
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='both',
        parameters=[
            {'use_sim_time': True},
        ],
    )

    # Joint state publisher
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
        parameters=[
            {'use_sim_time': True},
        ],
    )

    # Controllers
    controller_manager = Node(
        package='controller_manager',
        executable='ros2_control_node',
        parameters=[
            PathJoinSubstitution([
                FindPackageShare('humanoid_control'),
                'config',
                'ros2_controllers.yaml'
            ]),
            {'use_sim_time': True}
        ],
        remappings=[
            ('/robot_description', '/robot_description'),
        ],
        output='both',
    )

    return LaunchDescription([
        use_sim_time,
        world_file,
        gazebo,
        robot_state_publisher,
        joint_state_publisher,
        controller_manager,
    ])
```

### 2. Create a simple walking controller node:

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from builtin_interfaces.msg import Duration
from controller_manager_msgs.srv import SwitchController
import numpy as np
import time

class WalkingController(Node):
    def __init__(self):
        super().__init__('walking_controller')

        # Publishers for joint commands
        self.left_leg_pub = self.create_publisher(
            Float64MultiArray,
            '/left_leg_controller/commands',
            10
        )

        self.right_leg_pub = self.create_publisher(
            Float64MultiArray,
            '/right_leg_controller/commands',
            10
        )

        # Subscriber for joint states
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Controller switching service client
        self.switch_client = self.create_client(
            SwitchController,
            '/controller_manager/switch_controller'
        )

        # Walking parameters
        self.walking_freq = 0.5  # Hz
        self.step_height = 0.1   # meters
        self.step_length = 0.2   # meters
        self.current_phase = 0.0

        # Joint names and positions
        self.joint_names = []
        self.joint_positions = {}

        # Timer for walking pattern
        self.walk_timer = self.create_timer(0.01, self.walk_step)

        self.get_logger().info('Walking Controller initialized')

    def joint_state_callback(self, msg):
        """Update joint positions from joint states"""
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_positions[name] = msg.position[i]

    def walk_step(self):
        """Generate walking pattern based on current phase"""
        # Update phase
        self.current_phase += 2 * np.pi * self.walking_freq * 0.01

        if self.current_phase > 2 * np.pi:
            self.current_phase = 0.0

        # Generate walking pattern
        left_hip = self.step_length * np.sin(self.current_phase)
        left_knee = self.step_height * np.sin(self.current_phase * 2)
        left_ankle = -self.step_height * np.sin(self.current_phase * 2)

        right_hip = self.step_length * np.sin(self.current_phase + np.pi)
        right_knee = self.step_height * np.sin(self.current_phase * 2 + np.pi)
        right_ankle = -self.step_height * np.sin(self.current_phase * 2 + np.pi)

        # Create and publish commands
        left_cmd = Float64MultiArray()
        left_cmd.data = [left_hip, left_knee, left_ankle]
        self.left_leg_pub.publish(left_cmd)

        right_cmd = Float64MultiArray()
        right_cmd.data = [right_hip, right_knee, right_ankle]
        self.right_leg_pub.publish(right_cmd)

def main(args=None):
    rclpy.init(args=args)
    controller = WalkingController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Summary and Looking Ahead

In Weeks 4-5, you've learned the fundamentals of Gazebo simulation and how to apply them to humanoid robotics:

1. **Gazebo Architecture**: Understanding the core components and how they work together
2. **Robot Modeling**: Creating detailed URDF models for humanoid robots
3. **World Creation**: Building complex simulation environments
4. **Sensor Simulation**: Implementing realistic sensor models
5. **Physics Tuning**: Optimizing physics parameters for stable simulation
6. **ROS Integration**: Connecting Gazebo with ROS 2 systems
7. **Advanced Techniques**: Domain randomization and multi-robot simulation
8. **Debugging**: Troubleshooting common simulation issues

### Exercises for Weeks 4-5

1. Create a complete humanoid robot model in URDF with proper mass, inertia, and joint limits
2. Build a complex environment with obstacles, ramps, and interactive elements
3. Implement realistic sensor models for your humanoid robot
4. Tune physics parameters for stable humanoid locomotion
5. Create a launch file that starts your complete simulation
6. Implement a simple walking controller and test it in simulation
7. Add domain randomization to improve sim-to-real transfer
8. Create a multi-robot simulation scenario

### Looking Ahead to Week 6

Week 6 will focus on Unity integration for robotics simulation, exploring how Unity's high-fidelity graphics and physics can be leveraged for humanoid robotics applications, particularly for computer vision training and human-robot interaction studies.

[Continue to Week 6: Unity Robotics Integration](./week-06.md)

## References and Resources

- Gazebo Documentation: http://gazebosim.org/
- ROS 2 with Gazebo: https://classic.gazebosim.org/tutorials?tut=ros2_overview
- URDF Tutorials: http://wiki.ros.org/urdf/Tutorials
- ros2_control: https://control.ros.org/
- Physics Parameter Tuning: http://gazebosim.org/tutorials?tut=physics_params