---
sidebar_position: 3
title: "Week 1-2: ROS 2 Architecture Overview"
---

# Week 1-2: ROS 2 Architecture Overview

## Introduction to ROS 2 Architecture

Welcome to the first two weeks of our comprehensive course on Physical AI and Humanoid Robotics. This week focuses on understanding the fundamental architecture of Robot Operating System 2 (ROS 2), which serves as the communication backbone for modern robotic systems. By the end of these two weeks, you'll have a solid understanding of ROS 2's core concepts and will be ready to build your first robotic applications.

ROS 2 represents a significant evolution from its predecessor, addressing critical limitations while maintaining the modular, communication-based approach that made ROS 1 so successful. The architecture of ROS 2 is built around distributed computing principles, making it suitable for complex robotic systems that may span multiple machines and require real-time performance.

The architecture of ROS 2 is fundamentally different from ROS 1 in several key ways. Most notably, ROS 2 uses a peer-to-peer network model based on the Data Distribution Service (DDS) standard, eliminating the single point of failure that existed in ROS 1's master-based architecture. This change provides improved reliability, scalability, and security for robotic applications.

## Core Architecture Components

### Nodes: The Building Blocks of ROS 2

Nodes are the fundamental computational units in ROS 2. Each node performs a specific function within the larger robotic system and communicates with other nodes through the ROS 2 communication infrastructure. In a humanoid robot, different nodes might handle sensor data processing, motor control, perception, planning, and high-level decision making.

A node in ROS 2 is implemented as a process that can run on any machine in the network. Each node creates a client library instance that handles communication with the ROS 2 middleware. This design allows nodes to be distributed across multiple machines while maintaining transparent communication.

When creating a node, you must consider its computational requirements, real-time constraints, and resource usage. Nodes should be designed to perform a single, well-defined function, following the Unix philosophy of doing one thing well. This modularity makes the system more maintainable, testable, and reusable.

### Topics and Message Passing

Topics form the foundation of ROS 2's publish-subscribe communication model. A topic is a named bus over which nodes exchange messages. Publishers send messages to a topic, and subscribers receive messages from a topic. This decoupling of publishers and subscribers provides flexibility in system design and allows for multiple publishers and subscribers to interact on the same topic.

The message passing system in ROS 2 is type-safe, meaning that all messages on a topic must be of the same type. This prevents runtime errors that could occur if incompatible message types were mixed. Message types are defined using the `.msg` file format, which specifies the data fields and their types.

Quality of Service (QoS) policies control how messages are delivered between nodes. These policies include reliability (whether all messages must be delivered), durability (whether late-joining subscribers receive previous messages), and history depth (how many messages are stored). Understanding QoS is crucial for optimizing system performance and meeting real-time requirements.

### Services: Request-Response Communication

While topics are excellent for streaming data, services provide a request-response communication pattern that is essential for operations that require immediate feedback or must be performed by a single node. A service consists of a request message type and a response message type, defining the interface between client and server nodes.

Service calls are synchronous by default, meaning the client waits for the response before continuing. This can block the client node, so it's important to consider the timing implications when designing service-based systems. For long-running operations, actions (discussed below) may be more appropriate.

Services are particularly useful for operations like:
- Saving robot configuration
- Requesting system diagnostics
- Triggering calibration procedures
- Querying persistent data
- Performing administrative functions

### Actions: Long-Running Operations

Actions are designed for operations that take time to complete and may need to be monitored or canceled. An action interface includes three message types: goal, feedback, and result. The goal defines what the action should do, feedback provides ongoing status updates, and the result contains the final outcome.

Actions are ideal for tasks like:
- Navigation to a goal location
- Manipulation tasks that involve multiple steps
- Calibration procedures that take time
- Data collection operations
- Any task that might need to be interrupted

The action client can send a goal, receive feedback during execution, and get the final result. The action server can provide periodic feedback, handle preemption requests, and return results when complete.

### Parameters: Configuration Management

Parameters provide a way for nodes to be configured at runtime. Each node can declare parameters that can be set when the node starts or changed dynamically during operation. Parameters are stored in a parameter server and can be accessed by name.

Parameter management is crucial for deploying the same code in different environments. For example, a navigation node might have parameters for maximum speed, obstacle clearance distance, and goal tolerance that can be adjusted for different robots or environments without changing code.

Parameters can be:
- Set at launch time through launch files
- Modified during runtime through command-line tools
- Loaded from configuration files
- Remotely configured through services

## Understanding DDS and Its Role in ROS 2

The Data Distribution Service (DDS) is the underlying middleware that powers ROS 2's communication. DDS is an OMG (Object Management Group) standard for real-time, distributed data exchange. It provides the infrastructure for the publish-subscribe, request-response, and action communication patterns that ROS 2 exposes.

DDS provides several advantages over ROS 1's custom communication layer:
- Industry-standard implementation with multiple vendors
- Built-in Quality of Service controls
- Real-time performance capabilities
- Security features including authentication and encryption
- Language and platform independence
- Scalability to large, distributed systems

Understanding DDS concepts helps you optimize ROS 2 performance and troubleshoot communication issues. DDS domains allow multiple ROS 2 systems to run on the same network without interfering with each other. Each domain is isolated, allowing for separate development, testing, and production systems.

## Quality of Service (QoS) in Depth

QoS policies in ROS 2 allow you to fine-tune communication behavior to meet specific requirements. Different types of data have different needs for reliability, latency, and other factors. Understanding and properly configuring QoS is essential for system performance.

### Reliability Policy
The reliability policy determines whether messages must be delivered reliably or if some loss is acceptable:
- RELIABLE: All messages are delivered, with retries if necessary
- BEST_EFFORT: Messages are sent without guarantees of delivery

Sensor data streams often use BEST_EFFORT because a few lost messages are acceptable, while critical control commands typically use RELIABLE to ensure delivery.

### Durability Policy
The durability policy controls whether late-joining subscribers receive previously published messages:
- TRANSIENT_LOCAL: Late joiners receive recent messages from the publisher
- VOLATILE: Late joiners only receive new messages

Parameter updates and configuration data typically use TRANSIENT_LOCAL so new nodes can receive the current configuration, while sensor streams usually use VOLATILE since old sensor data is no longer relevant.

### History Policy
The history policy determines how many messages are stored for delivery:
- KEEP_LAST: Store the most recent N messages
- KEEP_ALL: Store all messages (limited by memory)

### Deadline and Lifespan
The deadline policy specifies the maximum time between consecutive messages, while the lifespan policy specifies how long messages remain valid after publication. These policies are important for real-time systems where data has a limited useful lifetime.

## Practical Implementation: Creating Your First ROS 2 System

Let's implement a simple but complete ROS 2 system that demonstrates the core concepts. We'll create a system that simulates a basic humanoid robot with sensors and a simple control system.

First, let's create a package for our example:

```bash
ros2 pkg create --build-type ament_python robot_basics
```

Now, let's create a sensor node that publishes IMU data:

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from std_msgs.msg import Float64
import random
import math

class ImuSensor(Node):
    def __init__(self):
        super().__init__('imu_sensor')

        # Create publisher for IMU data
        self.imu_publisher = self.create_publisher(Imu, 'imu/data', 10)

        # Create publisher for joint position feedback
        self.joint_publisher = self.create_publisher(Float64, 'joint/position', 10)

        # Timer for publishing data at 50 Hz
        timer_period = 0.02  # seconds (50 Hz)
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # Simulate robot state
        self.time = 0.0
        self.get_logger().info('IMU Sensor node started')

    def timer_callback(self):
        # Create and publish IMU message
        imu_msg = Imu()
        imu_msg.header.stamp = self.get_clock().now().to_msg()
        imu_msg.header.frame_id = 'base_link'

        # Simulate orientation (simplified)
        imu_msg.orientation.x = 0.0
        imu_msg.orientation.y = 0.0
        imu_msg.orientation.z = math.sin(self.time * 0.1) * 0.1
        imu_msg.orientation.w = math.cos(self.time * 0.1) * 0.1

        # Add some noise to make it realistic
        imu_msg.orientation_covariance[0] = 0.01
        imu_msg.orientation_covariance[4] = 0.01
        imu_msg.orientation_covariance[8] = 0.01

        # Simulate angular velocity
        imu_msg.angular_velocity.x = math.cos(self.time * 0.1) * 0.05
        imu_msg.angular_velocity.y = math.sin(self.time * 0.1) * 0.03
        imu_msg.angular_velocity.z = 0.01 + random.uniform(-0.01, 0.01)

        # Simulate linear acceleration
        imu_msg.linear_acceleration.x = math.sin(self.time * 0.2) * 0.5
        imu_msg.linear_acceleration.y = math.cos(self.time * 0.2) * 0.3
        imu_msg.linear_acceleration.z = 9.81 + random.uniform(-0.1, 0.1)

        self.imu_publisher.publish(imu_msg)

        # Publish simulated joint position
        joint_msg = Float64()
        joint_msg.data = math.sin(self.time * 0.5) * 0.5
        self.joint_publisher.publish(joint_msg)

        self.time += 0.02
        self.get_logger().debug(f'Published IMU data at time {self.time:.2f}')

def main(args=None):
    rclpy.init(args=args)
    imu_sensor = ImuSensor()

    try:
        rclpy.spin(imu_sensor)
    except KeyboardInterrupt:
        pass
    finally:
        imu_sensor.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Now let's create a controller node that subscribes to sensor data and publishes commands:

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from std_msgs.msg import Float64
import math

class BalanceController(Node):
    def __init__(self):
        super().__init__('balance_controller')

        # Subscribe to IMU data
        self.imu_subscription = self.create_subscription(
            Imu,
            'imu/data',
            self.imu_callback,
            10)

        # Subscribe to joint position feedback
        self.joint_subscription = self.create_subscription(
            Float64,
            'joint/position',
            self.joint_callback,
            10)

        # Publish joint commands
        self.command_publisher = self.create_publisher(Float64, 'joint/command', 10)

        # Controller state
        self.current_orientation = 0.0
        self.current_position = 0.0
        self.command_position = 0.0

        # Controller parameters
        self.kp = 2.0  # Proportional gain
        self.kd = 0.5  # Derivative gain

        # Timer for control loop
        self.prev_time = self.get_clock().now()
        self.prev_error = 0.0

        timer_period = 0.01  # 100 Hz control loop
        self.timer = self.create_timer(timer_period, self.control_loop)

        self.get_logger().info('Balance Controller node started')

    def imu_callback(self, msg):
        # Extract orientation from quaternion (simplified - assuming small angles)
        # In a real system, you'd use proper quaternion to Euler conversion
        self.current_orientation = math.atan2(
            2.0 * (msg.orientation.w * msg.orientation.z + msg.orientation.x * msg.orientation.y),
            1.0 - 2.0 * (msg.orientation.y * msg.orientation.y + msg.orientation.z * msg.orientation.z)
        )

    def joint_callback(self, msg):
        self.current_position = msg.data

    def control_loop(self):
        current_time = self.get_clock().now()
        dt = (current_time - self.prev_time).nanoseconds / 1e9

        if dt > 0.1:  # Reset if too much time has passed
            self.prev_time = current_time
            self.prev_error = 0.0
            return

        # Simple PD controller to maintain upright position
        error = -self.current_orientation  # Negative because we want to counter the tilt
        error_derivative = (error - self.prev_error) / dt if dt > 0 else 0.0

        # Calculate control output
        control_output = self.kp * error + self.kd * error_derivative

        # Apply limits to prevent excessive commands
        control_output = max(-1.0, min(1.0, control_output))

        # Update command position (simple integration)
        self.command_position += control_output * dt
        self.command_position = max(-1.0, min(1.0, self.command_position))

        # Publish command
        cmd_msg = Float64()
        cmd_msg.data = self.command_position
        self.command_publisher.publish(cmd_msg)

        # Log control information
        self.get_logger().debug(
            f'Orientation: {self.current_orientation:.3f}, '
            f'Error: {error:.3f}, '
            f'Command: {control_output:.3f}'
        )

        self.prev_error = error
        self.prev_time = current_time

def main(args=None):
    rclpy.init(args=args)
    controller = BalanceController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Launch Files for System Management

Launch files allow you to start multiple nodes with a single command and configure their parameters. Here's a launch file for our example system:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='robot_basics',
            executable='imu_sensor',
            name='imu_sensor',
            parameters=[
                {'sensor_rate': 50},
                {'noise_level': 0.01}
            ],
            output='screen'
        ),
        Node(
            package='robot_basics',
            executable='balance_controller',
            name='balance_controller',
            parameters=[
                {'kp': 2.0},
                {'kd': 0.5},
                {'control_rate': 100}
            ],
            output='screen'
        )
    ])
```

## Advanced ROS 2 Concepts

### Composition and Intra-Process Communication

ROS 2 supports node composition, where multiple nodes can run in the same process to reduce communication overhead. This is particularly useful for performance-critical applications where the overhead of inter-process communication is too high.

Intra-process communication allows nodes in the same process to communicate directly through shared memory, bypassing the DDS layer entirely. This can provide significant performance improvements for high-frequency data exchange.

### Lifecycle Nodes

Lifecycle nodes provide a standardized way to manage the state of complex nodes. They support states like unconfigured, inactive, active, and finalized, with defined transitions between states. This is particularly useful for nodes that need to initialize hardware or load large data sets.

The lifecycle node pattern ensures that nodes are properly initialized and can be gracefully started, stopped, and reconfigured. This is important for production robotic systems that need to be managed reliably.

### Real-time Considerations

For real-time applications, ROS 2 provides several features:
- Real-time safe allocators that don't cause unpredictable delays
- Lock-free data structures for communication
- Integration with real-time operating systems
- Support for real-time scheduling policies

When developing real-time systems, it's important to avoid operations that can cause unpredictable delays, such as dynamic memory allocation in time-critical paths.

## Security in ROS 2

Security is a critical concern for modern robotic systems, especially those operating in human environments. ROS 2 includes built-in security features based on DDS Security, including:

- Authentication: Verifying the identity of nodes
- Access control: Controlling which nodes can communicate
- Encryption: Protecting data in transit

Security policies can be configured to meet specific requirements for different applications, from research environments to commercial deployments.

## Performance Optimization Strategies

Optimizing ROS 2 performance requires understanding several key areas:

### Message Design
- Use appropriate data types to minimize bandwidth
- Consider message size when designing interfaces
- Use fixed-size arrays when possible
- Implement custom message types for efficiency

### QoS Configuration
- Match QoS policies to application requirements
- Use BEST_EFFORT for high-frequency sensor data
- Use RELIABLE for critical control commands
- Configure history depth appropriately

### Network Configuration
- Use local networks for high-bandwidth data
- Configure DDS for optimal performance
- Consider multicast for sensor data distribution
- Use compression for large data sets

## Debugging and Monitoring Tools

ROS 2 provides extensive tools for debugging and monitoring:

- `rqt`: A Qt-based GUI for visualizing and controlling ROS 2 systems
- `ros2 topic`: Command-line tools for inspecting topic data
- `ros2 service`: Tools for calling and monitoring services
- `ros2 action`: Tools for interacting with actions
- `ros2 param`: Tools for managing parameters
- `ros2 bag`: Tools for recording and replaying data

These tools are essential for understanding system behavior and identifying issues.

## Integration with Simulation

ROS 2 integrates seamlessly with simulation environments like Gazebo, allowing for safe and efficient development of robotic applications. Simulation nodes can publish the same message types as real sensors, allowing the same processing code to work in both simulation and reality.

This simulation integration is crucial for humanoid robotics development, where testing on real robots can be expensive and potentially dangerous during development phases.

## Best Practices for ROS 2 Development

### Node Design
- Keep nodes focused on single responsibilities
- Use descriptive names that indicate function
- Implement proper error handling and recovery
- Design for reusability and modularity

### Message Design
- Use standard message types when possible
- Design messages for efficiency
- Consider bandwidth requirements
- Document message semantics clearly

### Parameter Management
- Use parameters for configuration rather than hardcoding values
- Provide reasonable defaults
- Validate parameter values
- Document parameter meanings and ranges

### Testing
- Write comprehensive unit tests
- Implement integration tests
- Use simulation for system testing
- Test error conditions and recovery

## Common Pitfalls and Solutions

### Memory Management
- Avoid dynamic allocation in time-critical paths
- Use pre-allocated message pools for high-frequency topics
- Implement proper cleanup in node destruction

### Timing Issues
- Use ROS time instead of system time
- Account for network latency in timing calculations
- Implement proper synchronization for multi-node systems

### Resource Conflicts
- Use unique names for topics and services
- Implement proper namespace management
- Consider resource usage when designing systems

## Future Considerations

As you continue developing with ROS 2, keep in mind emerging trends and developments:

- ROS 2 continues to evolve with new features and improvements
- The ecosystem of packages and tools is expanding rapidly
- Integration with AI and machine learning frameworks is improving
- Real-time and safety-critical applications are becoming more common

## Exercises for Week 1-2

1. Create a ROS 2 package that implements a simple sensor-controller system for a different type of sensor (e.g., camera, LIDAR, or force sensor).

2. Modify the example code to include multiple joints and implement coordinated control.

3. Create a launch file that starts your system with different parameter configurations.

4. Use rosbag2 to record and replay data from your system.

5. Implement a simple service that allows external control of your controller parameters.

6. Create a visualization node that subscribes to your system's data and publishes markers for rviz2.

7. Implement a lifecycle node version of one of your simple nodes.

8. Experiment with different QoS policies and observe their effects on system behavior.

## Week 2 Focus: Advanced Topics and Integration

Week 2 will build on the foundational concepts introduced in Week 1, focusing on more advanced topics:

- Advanced message types and custom message creation
- Complex system integration and debugging
- Performance optimization techniques
- Security configuration and implementation
- Integration with simulation environments

By the end of these two weeks, you'll have a solid foundation in ROS 2 architecture and will be ready to tackle more complex robotic systems.

## Troubleshooting Common Issues

### Network Configuration
If nodes cannot communicate across machines:
- Check firewall settings
- Ensure ROS_DOMAIN_ID is the same on all machines
- Verify network connectivity with ping
- Check that DDS implementations are compatible

### Performance Issues
If experiencing high latency or dropped messages:
- Monitor network bandwidth usage
- Check QoS configuration
- Consider message size and frequency
- Profile node performance to identify bottlenecks

### Build and Runtime Issues
Common build issues include:
- Missing dependencies in package.xml
- Incorrect build type in setup.py or CMakeLists.txt
- Missing ament hooks for Python packages
- Path configuration issues

## Summary

In these first two weeks, you've learned the fundamental architecture of ROS 2 and implemented a simple but complete robotic system. You understand the core concepts of nodes, topics, services, actions, and parameters, and you've seen how they work together to create distributed robotic applications.

The modular, communication-based approach of ROS 2 enables the development of complex, distributed robotic systems that can integrate multiple sensors, actuators, and processing components. This foundation will serve you well as you continue through the course and develop more sophisticated humanoid robotic systems.

In the next weeks, you'll explore simulation environments that allow you to test and develop your ROS 2 applications in a safe, controlled environment before deploying them on real hardware.

[Continue to Week 3: Advanced ROS 2 Concepts](./week-03.md)

## References and Resources

- ROS 2 Documentation: https://docs.ros.org/en/humble/
- DDS Specification: https://www.omg.org/spec/DDS/
- ROS 2 Design Papers: Available through the Open Robotics website
- Example Packages: https://github.com/ros2/examples
- Tutorials: https://docs.ros.org/en/humble/Tutorials.html